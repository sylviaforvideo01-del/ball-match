<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁêÉÁêÉÊ∂àÊ∂à‰πê - Ball Match v1.4</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { font-family: 'Microsoft YaHei', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; overflow: hidden; touch-action: none; }
        #gameContainer { width: 100%; height: 100vh; display: flex; flex-direction: column; position: relative; }
        #topBar { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); flex-shrink: 0; }
        #levelInfo { color: white; font-size: clamp(14px, 4vw, 18px); font-weight: bold; }
        #scoreInfo { color: #FFD700; font-size: clamp(12px, 3.5vw, 16px); }
        #gameArea { flex: 1; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        #board { position: relative; width: 100%; height: 100%; }
        .ball { position: absolute; border-radius: 50%; cursor: pointer; transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55); display: flex; align-items: center; justify-content: center; font-size: clamp(14px, 3.5vw, 20px); box-shadow: inset -3px -3px 8px rgba(255,255,255,0.9), inset 3px 3px 8px rgba(255,255,255,0.5), inset 2px 2px 6px rgba(0,0,0,0.15), 0 6px 12px rgba(0,0,0,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .ball::before { content: ''; position: absolute; top: 8%; left: 15%; width: 28%; height: 20%; background: radial-gradient(ellipse at center, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 50%, transparent 70%); border-radius: 50%; transform: rotate(-25deg); }
        .ball::after { content: ''; position: absolute; bottom: 12%; right: 18%; width: 18%; height: 12%; background: radial-gradient(ellipse at center, rgba(255,255,255,0.6) 0%, transparent 70%); border-radius: 50%; }
        .ball.clickable { animation: float 2s ease-in-out infinite; }
        .ball.clickable:hover { transform: scale(1.08); filter: brightness(1.15); }
        .ball.blocked { opacity: 0.85; filter: brightness(0.7); cursor: not-allowed; }
        .ball.blocked::after { content: 'üîí'; position: absolute; font-size: 12px; bottom: 5%; right: 5%; opacity: 0.7; }
        .ball.selected { animation: bounce 0.5s ease-in-out infinite; box-shadow: inset -3px -3px 8px rgba(255,255,255,0.95), inset 3px 3px 8px rgba(255,255,255,0.6), 0 0 25px rgba(255,255,255,0.7), 0 0 0 4px rgba(255,255,255,0.5); }
        .ball.hint { animation: hintPulse 1s ease-in-out infinite; box-shadow: 0 0 20px #FFD700, 0 0 40px #FFD700; }
        .ball.removing { animation: popOut 0.3s ease-out forwards; }
        @keyframes hintPulse { 0%, 100% { box-shadow: 0 0 20px #FFD700; } 50% { box-shadow: 0 0 40px #FFD700, 0 0 60px #FFD700; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        @keyframes bounce { 0%, 100% { transform: scale(1.05) translateY(0); } 50% { transform: scale(1.1) translateY(-5px); } }
        @keyframes popOut { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.25); opacity: 0.9; } 100% { transform: scale(0); opacity: 0; } }
        #slotArea { height: clamp(65px, 11vh, 85px); background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; padding: 8px; gap: clamp(3px, 1vw, 8px); position: relative; flex-shrink: 0; }
        #slotLabel { position: absolute; left: 10px; color: rgba(255,255,255,0.7); font-size: clamp(9px, 2.5vw, 11px); }
        .slot { border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px dashed rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; }
        .slot.filled { border: none; background: transparent; }
        #toolsArea { position: absolute; bottom: clamp(75px, 13vh, 100px); left: 50%; transform: translateX(-50%); display: flex; gap: clamp(8px, 2.5vw, 16px); z-index: 100; background: rgba(0,0,0,0.2); padding: 8px 15px; border-radius: 50px; }
        .toolWrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .toolBtn { width: clamp(44px, 10vw, 56px); height: clamp(44px, 10vw, 56px); border-radius: 50%; border: none; background: linear-gradient(145deg, #FFD700, #FFA500); color: white; font-size: clamp(16px, 4vw, 22px); cursor: pointer; box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4); transition: all 0.2s; display: flex; align-items: center; justify-content: center; position: relative; }
        .toolBtn:hover { transform: scale(1.1); box-shadow: 0 6px 18px rgba(255, 165, 0, 0.6); }
        .toolBtn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .toolCount { position: absolute; top: -4px; right: -4px; background: #ff4444; color: white; width: clamp(16px, 4vw, 22px); height: clamp(16px, 4vw, 22px); border-radius: 50%; font-size: clamp(9px, 2.5vw, 12px); display: flex; align-items: center; justify-content: center; font-weight: bold; }
        .toolLabel { color: rgba(255,255,255,0.9); font-size: clamp(9px, 2.5vw, 11px); white-space: nowrap; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; }
        .modal.show { opacity: 1; visibility: visible; }
        .modalContent { background: linear-gradient(145deg, #667eea, #764ba2); padding: clamp(20px, 6vw, 35px); border-radius: 20px; text-align: center; color: white; max-width: min(320px, 85vw); width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5); transform: scale(0.8); transition: transform 0.3s; }
        .modal.show .modalContent { transform: scale(1); }
        .modalTitle { font-size: clamp(20px, 5.5vw, 26px); margin-bottom: 12px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .modalText { font-size: clamp(13px, 3.5vw, 15px); margin-bottom: 22px; opacity: 0.9; }
        .modalBtn { padding: clamp(10px, 3.5vw, 14px) clamp(25px, 7vw, 35px); font-size: clamp(15px, 4vw, 17px); border: none; border-radius: 30px; background: linear-gradient(145deg, #FFD700, #FFA500); color: white; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(255, 165, 0, 0.4); transition: all 0.2s; }
        .modalBtn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(255, 165, 0, 0.6); }
        #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; padding: 20px; }
        #gameTitle { font-size: clamp(28px, 9vw, 44px); color: white; text-shadow: 3px 3px 6px rgba(0,0,0,0.3); margin-bottom: 12px; text-align: center; }
        #gameSubtitle { font-size: clamp(13px, 3.5vw, 16px); color: rgba(255,255,255,0.8); margin-bottom: 35px; text-align: center; }
        .demoBall { width: clamp(50px, 15vw, 70px); height: clamp(50px, 15vw, 70px); border-radius: 50%; margin: clamp(4px, 1.5vw, 8px); display: inline-block; animation: demoBounce 1s ease-in-out infinite; box-shadow: inset -3px -3px 8px rgba(255,255,255,0.9), inset 3px 3px 8px rgba(255,255,255,0.5), 0 6px 12px rgba(0,0,0,0.4); }
        .demoBall:nth-child(2) { animation-delay: 0.1s; }
        .demoBall:nth-child(3) { animation-delay: 0.2s; }
        @keyframes demoBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }
        #startBtn { padding: clamp(12px, 4vw, 18px) clamp(35px, 10vw, 55px); font-size: clamp(16px, 4.5vw, 22px); border: none; border-radius: 50px; background: linear-gradient(145deg, #FFD700, #FFA500); color: white; cursor: pointer; font-weight: bold; box-shadow: 0 6px 20px rgba(255, 165, 0, 0.4); transition: all 0.3s; margin-top: 35px; }
        #startBtn:hover { transform: scale(1.1); box-shadow: 0 8px 30px rgba(255, 165, 0, 0.6); }
        .particle { position: absolute; width: clamp(5px, 1.5vw, 9px); height: clamp(5px, 1.5vw, 9px); border-radius: 50%; pointer-events: none; animation: particleFade 0.6s ease-out forwards; }
        @keyframes particleFade { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        #comboText { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(28px, 9vw, 44px); font-weight: bold; color: #FFD700; text-shadow: 3px 3px 6px rgba(0,0,0,0.5); pointer-events: none; opacity: 0; z-index: 500; }
        .comboShow { animation: comboAnim 1s ease-out forwards; }
        @keyframes comboAnim { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 80% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1) translateY(-40px); opacity: 0; } }
        #levelProgress { position: absolute; top: 45px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.8); font-size: clamp(11px, 3vw, 13px); background: rgba(0,0,0,0.2); padding: 4px 12px; border-radius: 15px; }
        #versionDisplay { position: fixed; bottom: 5px; right: 10px; color: rgba(255,255,255,0.4); font-size: 10px; z-index: 100; }
        #soundControls { position: absolute; top: 10px; right: 10px; display: flex; gap: 8px; z-index: 100; }
        .soundBtn { width: 36px; height: 36px; border-radius: 50%; border: none; background: rgba(255,255,255,0.2); color: white; font-size: 16px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1 id="gameTitle">ÁêÉÁêÉÊ∂àÊ∂à‰πê</h1>
        <p id="gameSubtitle">ÁÇπÂáªÁêÉÁêÉÔºå‰∏â‰∏™Áõ∏ÂêåÈ¢úËâ≤Âç≥ÂèØÊ∂àÈô§</p>
        <div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #ff0000, #cc0000);"></div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #0066ff, #0044cc);"></div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #ffcc00, #ff9900);"></div>
        </div>
        <button id="startBtn">ÂºÄÂßãÊ∏∏Êàè</button>
    </div>

    <div id="gameContainer" style="display: none;">
        <div id="versionDisplay">v1.3</div>
        <div id="soundControls">
            <button class="soundBtn" id="clickSoundBtn" title="ÁÇπÂáªÈü≥Êïà">üéµ</button>
            <button class="soundBtn" id="cheerSoundBtn" title="ÂñùÂΩ©Èü≥Êïà">üéâ</button>
        </div>
        <div id="topBar">
            <div id="levelInfo">Á¨¨ 1 ÂÖ≥</div>
            <div id="scoreInfo">ÂæóÂàÜ: 0</div>
        </div>
        <div id="levelProgress">ÂÖ≥Âç° 1/15</div>
        <div id="gameArea">
            <div id="board"></div>
        </div>
        <div id="toolsArea">
            <div class="toolWrapper">
                <button class="toolBtn" id="shuffleBtn">üîÑ<span class="toolCount" id="shuffleCount">3</span></button>
                <span class="toolLabel">Êâì‰π±</span>
            </div>
            <div class="toolWrapper">
                <button class="toolBtn" id="undoBtn">‚Ü©Ô∏è<span class="toolCount" id="undoCount">3</span></button>
                <span class="toolLabel">Êí§ÈîÄ</span>
            </div>
            <div class="toolWrapper">
                <button class="toolBtn" id="hintBtn">üí°<span class="toolCount" id="hintCount">3</span></button>
                <span class="toolLabel">ÊèêÁ§∫</span>
            </div>
        </div>
        <div id="slotArea">
            <span id="slotLabel">ÊßΩ‰Ωç</span>
            <div class="slot" data-index="0"></div>
            <div class="slot" data-index="1"></div>
            <div class="slot" data-index="2"></div>
            <div class="slot" data-index="3"></div>
            <div class="slot" data-index="4"></div>
            <div class="slot" data-index="5"></div>
            <div class="slot" data-index="6"></div>
        </div>
    </div>
    <div id="comboText"></div>
    <div id="gameOverModal" class="modal">
        <div class="modalContent">
            <h2 class="modalTitle">Ê∏∏ÊàèÁªìÊùü</h2>
            <p class="modalText">ÊßΩ‰ΩçÂ∑≤Êª°ÔºåÂÜçËØï‰∏ÄÊ¨°ÂêßÔºÅ</p>
            <button class="modalBtn" onclick="game.restart()">ÂÜçÁé©‰∏ÄÊ¨°</button>
        </div>
    </div>
    <div id="winModal" class="modal">
        <div class="modalContent">
            <h2 class="modalTitle" id="winTitle">ÊÅ≠ÂñúÈÄöÂÖ≥ÔºÅ</h2>
            <p class="modalText" id="winText">Â§™Ê£í‰∫ÜÔºÅ‰Ω†ÊàêÂäüÊ∂àÈô§‰∫ÜÊâÄÊúâÁêÉÁêÉÔºÅ</p>
            <button class="modalBtn" id="nextBtn" onclick="game.nextLevel()">‰∏ã‰∏ÄÂÖ≥</button>
        </div>
    </div>
    <script>
        class SoundManager {
            constructor() { this.clickEnabled = true; this.cheerEnabled = true; this.audioContext = null; }
            init() { try { this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }
            playClick() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(800, 0.05, 0.1, 'sine', 0.2); }
            playMatch() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(600, 0.1, 0.15, 'sine', 0.2); setTimeout(() => this.playTone(800, 0.1, 0.15, 'sine', 0.2), 80); setTimeout(() => this.playTone(1000, 0.15, 0.2, 'sine', 0.2), 160); }
            playCheer() { if (!this.cheerEnabled || !this.audioContext) return; [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => this.playTone(f, 0.1, 0.3, 'triangle', 0.25), i * 100)); }
            playWin() { if (!this.cheerEnabled || !this.audioContext) return; [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.playTone(f, 0.15, 0.2, 'triangle', 0.3), i * 120)); }
            playLose() { if (!this.cheerEnabled || !this.audioContext) return; [400, 350, 300, 250].forEach((f, i) => setTimeout(() => this.playTone(f, 0.2, 0.25, 'sawtooth', 0.2), i * 100)); }
            playTool() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(500, 0.08, 0.12, 'square', 0.2); setTimeout(() => this.playTone(700, 0.08, 0.12, 'square', 0.2), 60); }
            playCombo() { if (!this.cheerEnabled || !this.audioContext) return; this.playTone(880, 0.1, 0.15, 'sine', 0.25); }
            playTone(f, a, d, t, v) { if (!this.audioContext) return; const o = this.audioContext.createOscillator(), g = this.audioContext.createGain(); o.connect(g); g.connect(this.audioContext.destination); o.frequency.value = f; o.type = t; const n = this.audioContext.currentTime; g.gain.setValueAtTime(0, n); g.gain.linearRampToValueAtTime(v, n + a); g.gain.exponentialRampToValueAtTime(0.01, n + a + d); o.start(n); o.stop(n + a + d + 0.05); }
            toggleClick() { return this.clickEnabled = !this.clickEnabled; }
            toggleCheer() { return this.cheerEnabled = !this.cheerEnabled; }
        }
        const CONFIG = {
            slotCount: 7,
            colors: [
                { name: 'red', bg: 'radial-gradient(circle at 30% 30%, #ff0000, #cc0000)', emoji: 'üî¥' },
                { name: 'blue', bg: 'radial-gradient(circle at 30% 30%, #0066ff, #0044cc)', emoji: 'üîµ' },
                { name: 'yellow', bg: 'radial-gradient(circle at 30% 30%, #ffcc00, #ff9900)', emoji: 'üü°' },
                { name: 'green', bg: 'radial-gradient(circle at 30% 30%, #00cc00, #009900)', emoji: 'üü¢' },
                { name: 'purple', bg: 'radial-gradient(circle at 30% 30%, #9900ff, #6600cc)', emoji: 'üü£' },
                { name: 'orange', bg: 'radial-gradient(circle at 30% 30%, #ff6600, #cc4400)', emoji: 'üü†' },
                { name: 'cyan', bg: 'radial-gradient(circle at 30% 30%, #00cccc, #009999)', emoji: 'üíé' },
                { name: 'pink', bg: 'radial-gradient(circle at 30% 30%, #ff66cc, #cc3399)', emoji: 'üíó' },
                { name: 'lime', bg: 'radial-gradient(circle at 30% 30%, #99ff00, #66cc00)', emoji: 'üçÄ' },
                { name: 'brown', bg: 'radial-gradient(circle at 30% 30%, #cc6600, #994400)', emoji: 'üü§' }
            ],
            levels: [
                { rows: 3, cols: 3, layers: 1, types: 1, name: "ÂàùÊ¨°‰ΩìÈ™å" },
                { rows: 3, cols: 3, layers: 1, types: 2, name: "ÁÆÄÂçï‰∏äÊâã" },
                { rows: 3, cols: 3, layers: 1, types: 3, name: "Ê∏êÂÖ•‰Ω≥Â¢É" },
                { rows: 3, cols: 3, layers: 1, types: 3, name: "Á®≥Ê≠•ÂâçËøõ" },
                { rows: 3, cols: 4, layers: 1, types: 3, name: "Â∞èÊúâÊàêÂ∞±" },
                { rows: 3, cols: 4, layers: 1, types: 4, name: "ÂàùÈú≤ÈîãËäí" },
                { rows: 3, cols: 4, layers: 1, types: 4, name: "ÊåëÊàòÂºÄÂßã" },
                { rows: 3, cols: 5, layers: 1, types: 4, name: "ÁªßÁª≠Âä†Ê≤π" },
                { rows: 3, cols: 5, layers: 1, types: 5, name: "Á™ÅÁ†¥Ëá™Êàë" },
                { rows: 4, cols: 5, layers: 1, types: 5, name: " halfway" },
                { rows: 4, cols: 5, layers: 1, types: 6, name: "Âõ∞ÈöæÈáçÈáç" },
                { rows: 4, cols: 6, layers: 1, types: 6, name: "ÁôªÂ≥∞ÈÄ†ÊûÅ" },
                { rows: 4, cols: 6, layers: 2, types: 7, name: "ÁéãËÄÖ‰πãË∑Ø" },
                { rows: 5, cols: 6, layers: 2, types: 8, name: "‰º†Â•áÈöæÂ∫¶" },
                { rows: 6, cols: 7, layers: 3, types: 10, name: "ÁªàÊûÅÊåëÊàò" }
            ]
        };
        class Game {
            constructor() { this.level = 1; this.score = 0; this.balls = []; this.slots = []; this.history = []; this.tools = { shuffle: 3, undo: 3, hint: 3 }; this.isProcessing = false; this.combo = 0; this.lastMatchTime = 0; this.ballSize = 50; this.ballGap = 6; this.soundManager = new SoundManager(); this.init(); }
            init() { this.bindEvents(); this.handleResize(); window.addEventListener('resize', () => this.handleResize()); }
            bindEvents() {
                document.getElementById('startBtn').addEventListener('click', () => { document.getElementById('startScreen').style.display = 'none'; document.getElementById('gameContainer').style.display = 'flex'; this.soundManager.init(); this.startLevel(); });
                document.getElementById('shuffleBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('shuffle'); });
                document.getElementById('undoBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('undo'); });
                document.getElementById('hintBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('hint'); });
                document.getElementById('clickSoundBtn').addEventListener('click', (e) => { const on = this.soundManager.toggleClick(); e.target.textContent = on ? 'üéµ' : 'üîá'; e.target.style.opacity = on ? '1' : '0.5'; });
                document.getElementById('cheerSoundBtn').addEventListener('click', (e) => { const on = this.soundManager.toggleCheer(); e.target.textContent = on ? 'üéâ' : 'üîá'; e.target.style.opacity = on ? '1' : '0.5'; });
            }
            handleResize() {
                const gameArea = document.getElementById('gameArea');
                const levelConfig = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)];
                const sizeByWidth = Math.floor(gameArea.clientWidth * 0.95 / (levelConfig.cols + levelConfig.layers * 0.15));
                const sizeByHeight = Math.floor(gameArea.clientHeight * 0.9 / (levelConfig.rows + levelConfig.layers * 0.15));
                this.ballSize = Math.max(32, Math.min(52, Math.min(sizeByWidth, sizeByHeight)));
                this.ballGap = Math.max(3, Math.floor(this.ballSize / 12));
                document.querySelectorAll('.slot').forEach(slot => { slot.style.width = this.ballSize + 'px'; slot.style.height = this.ballSize + 'px'; });
                if (this.balls.length > 0 && document.getElementById('gameContainer').style.display !== 'none') this.startLevel();
            }
            startLevel() { this.generateBoard(CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)]); this.updateUI(); }
            generateBoard(config) {
                this.balls = []; this.slots = []; this.history = []; this.updateSlots();
                const board = document.getElementById('board'); board.innerHTML = '';
                const totalBalls = config.rows * config.cols * config.layers;
                const usableBalls = Math.floor(totalBalls / 3) * 3;
                const colors = CONFIG.colors.slice(0, config.types);
                const ballData = [];
                const baseCount = Math.floor(usableBalls / config.types / 3) * 3;
                let remaining = usableBalls;
                colors.forEach(color => { for (let i = 0; i < baseCount; i++) ballData.push({ ...color, id: Math.random().toString(36).substr(2, 9) }); remaining -= baseCount; });
                let colorIdx = 0;
                while (remaining >= 3) {
                    const color = colors[colorIdx % colors.length];
                    for (let i = 0; i < 3; i++) ballData.push({ ...color, id: Math.random().toString(36).substr(2, 9) });
                    remaining -= 3; colorIdx++;
                }
                for (let i = ballData.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ballData[i], ballData[j]] = [ballData[j], ballData[i]]; }
                const gameArea = document.getElementById('gameArea');
                const ballTotalSize = this.ballSize + this.ballGap;
                const layerOffset = this.ballSize * 0.12;
                const boardWidth = config.cols * ballTotalSize + (config.layers - 1) * layerOffset;
                const boardHeight = config.rows * ballTotalSize + (config.layers - 1) * layerOffset;
                const offsetX = (gameArea.clientWidth - boardWidth) / 2;
                const offsetY = (gameArea.clientHeight - boardHeight) / 2;
                let ballIndex = 0;
                for (let layer = 0; layer < config.layers; layer++) {
                    for (let row = 0; row < config.rows; row++) {
                        for (let col = 0; col < config.cols; col++) {
                            if (ballIndex >= usableBalls) break;
                            const ball = document.createElement('div');
                            ball.className = 'ball';
                            ball.style.width = this.ballSize + 'px';
                            ball.style.height = this.ballSize + 'px';
                            ball.style.left = (offsetX + col * ballTotalSize + layer * layerOffset) + 'px';
                            ball.style.top = (offsetY + row * ballTotalSize + layer * layerOffset) + 'px';
                            ball.style.background = ballData[ballIndex].bg;
                            ball.style.zIndex = layer + 1;
                            ball.dataset.color = ballData[ballIndex].name;
                            ball.dataset.id = ballData[ballIndex].id;
                            ball.dataset.layer = layer;
                            ball.dataset.row = row;
                            ball.dataset.col = col;
                            ball.textContent = ballData[ballIndex].emoji;
                            ball.addEventListener('click', (e) => this.onBallClick(e, ball));
                            board.appendChild(ball); this.balls.push(ball); ballIndex++;
                        }
                    }
                }
                this.updateClickable();
            }
            updateClickable() {
                this.balls.forEach(ball => {
                    if (this.isBallBlocked(ball)) { ball.classList.add('blocked'); ball.classList.remove('clickable'); }
                    else { ball.classList.remove('blocked'); ball.classList.add('clickable'); }
                });
            }
            isBallBlocked(ball) {
                const layer = parseInt(ball.dataset.layer), row = parseInt(ball.dataset.row), col = parseInt(ball.dataset.col);
                const maxLayers = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)].layers;
                for (let l = layer + 1; l < maxLayers; l++) {
                    const covering = this.balls.filter(b => parseInt(b.dataset.layer) === l && !b.classList.contains('removing') && Math.abs(parseInt(b.dataset.row) - row) <= 1 && Math.abs(parseInt(b.dataset.col) - col) <= 1);
                    if (covering.length > 0) return true;
                }
                return false;
            }
            onBallClick(e, ball) {
                if (this.isProcessing || ball.classList.contains('blocked') || ball.classList.contains('removing') || this.slots.length >= CONFIG.slotCount) return;
                this.soundManager.playClick();
                this.history.push({ balls: this.balls.map(b => ({ id: b.dataset.id, inSlot: this.slots.includes(b), slotIndex: this.slots.indexOf(b) })), slots: [...this.slots], score: this.score });
                this.slots.push(ball); this.updateSlots();
                ball.classList.add('selected'); ball.style.position = 'relative'; ball.style.left = '0'; ball.style.top = '0';
                this.checkMatch(); this.updateClickable(); setTimeout(() => this.checkGameState(), 300);
            }
            updateSlots() {
                document.querySelectorAll('.slot').forEach((slot, index) => {
                    slot.innerHTML = ''; slot.classList.remove('filled');
                    if (this.slots[index]) { const ball = this.slots[index]; ball.classList.remove('selected'); ball.style.width = this.ballSize + 'px'; ball.style.height = this.ballSize + 'px'; slot.appendChild(ball); slot.classList.add('filled'); }
                });
            }
            checkMatch() {
                const colorCount = {};
                this.slots.forEach((ball, index) => { const color = ball.dataset.color; if (!colorCount[color]) colorCount[color] = []; colorCount[color].push(index); });
                for (const color in colorCount) { if (colorCount[color].length >= 3) { this.removeBalls(colorCount[color]); return; } }
            }
            removeBalls(indices) {
                this.isProcessing = true;
                const now = Date.now();
                if (now - this.lastMatchTime < 3000) this.combo++; else this.combo = 1;
                this.lastMatchTime = now;
                if (this.combo > 1) { this.showCombo(this.combo); this.soundManager.playCombo(); }
                else { this.soundManager.playMatch(); }
                this.score += (100 + (this.combo - 1) * 50) * indices.length;
                indices.forEach(index => this.createParticles(this.slots[index]));
                setTimeout(() => {
                    indices.sort((a, b) => b - a).forEach(index => {
                        const ball = this.slots[index]; ball.classList.add('removing');
                        setTimeout(() => { ball.remove(); this.balls = this.balls.filter(b => b !== ball); }, 300);
                        this.slots.splice(index, 1);
                    });
                    this.updateSlots(); this.updateUI(); this.isProcessing = false; setTimeout(() => this.checkWin(), 400);
                }, 100);
            }
            createParticles(ball) {
                const rect = ball.getBoundingClientRect();
                const bg = CONFIG.colors.find(c => c.name === ball.dataset.color)?.bg || '#fff';
                for (let i = 0; i < 8; i++) {
                    const p = document.createElement('div'); p.className = 'particle';
                    p.style.left = (rect.left + rect.width / 2) + 'px'; p.style.top = (rect.top + rect.height / 2) + 'px'; p.style.background = bg;
                    const angle = (i / 8) * Math.PI * 2;
                    p.style.setProperty('--tx', Math.cos(angle) * (40 + Math.random() * 40) + 'px');
                    p.style.setProperty('--ty', Math.sin(angle) * (40 + Math.random() * 40) + 'px');
                    document.body.appendChild(p); setTimeout(() => p.remove(), 600);
                }
            }
            showCombo(combo) {
                const texts = ['', 'ËøûÂáª!', 'ÂèåËøûÂáª!', '‰∏âËøûÂáª!', 'Ë∂ÖÁ•û!', 'Êó†Êïå!'];
                const comboText = document.getElementById('comboText');
                comboText.textContent = texts[Math.min(combo, texts.length - 1)];
                comboText.classList.remove('comboShow'); void comboText.offsetWidth; comboText.classList.add('comboShow');
            }
            checkGameState() { if (this.slots.length >= CONFIG.slotCount) { this.soundManager.playLose(); document.getElementById('gameOverModal').classList.add('show'); } }
            checkWin() {
                if (this.balls.length === 0) {
                    this.soundManager.playWin();
                    const levelConfig = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)];
                    if (this.level >= CONFIG.levels.length) {
                        document.getElementById('winTitle').textContent = 'üéâ ÊÅ≠ÂñúÈÄöÂÖ≥ÂÖ®ÈÉ®15ÂÖ≥ÔºÅ';
                        document.getElementById('winText').textContent = `ÊúÄÁªàÂæóÂàÜ: ${this.score}`;
                        document.getElementById('nextBtn').textContent = 'ÈáçÊñ∞ÂºÄÂßã';
                        document.getElementById('nextBtn').onclick = () => { this.level = 1; this.score = 0; document.getElementById('winModal').classList.remove('show'); this.startLevel(); };
                    } else {
                        document.getElementById('winTitle').textContent = `ÊÅ≠ÂñúÈÄöËøáÁ¨¨ ${this.level} ÂÖ≥ÔºÅ`;
                        document.getElementById('winText').textContent = `ÂÖ≥Âç°: ${levelConfig.name} | ÂæóÂàÜ: ${this.score}`;
                        document.getElementById('nextBtn').textContent = '‰∏ã‰∏ÄÂÖ≥';
                        document.getElementById('nextBtn').onclick = () => this.nextLevel();
                    }
                    document.getElementById('winModal').classList.add('show');
                }
            }
            useTool(type) { if (this.tools[type] <= 0) return; switch(type) { case 'shuffle': this.shuffleBalls(); break; case 'undo': this.undo(); break; case 'hint': this.showHint(); break; } this.tools[type]--; this.updateUI(); }
            shuffleBalls() {
                const clickableBalls = this.balls.filter(b => !b.classList.contains('blocked') && !this.slots.includes(b));
                const colors = clickableBalls.map(b => b.dataset.color);
                for (let i = colors.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [colors[i], colors[j]] = [colors[j], colors[i]]; }
                clickableBalls.forEach((ball, index) => { const colorData = CONFIG.colors.find(c => c.name === colors[index]); ball.dataset.color = colors[index]; ball.style.background = colorData.bg; ball.textContent = colorData.emoji; });
            }
            undo() {
                if (this.history.length === 0) return;
                const lastState = this.history.pop();
                this.slots = lastState.slots; this.updateSlots(); this.score = lastState.score; this.updateUI();
            }
            showHint() {
                const clickableBalls = this.balls.filter(b => !b.classList.contains('blocked') && !this.slots.includes(b));
                const colorCount = {};
                this.slots.forEach(ball => { const color = ball.dataset.color; colorCount[color] = (colorCount[color] || 0) + 1; });
                for (const color in colorCount) {
                    if (colorCount[color] >= 2) {
                        const matchingBalls = clickableBalls.filter(b => b.dataset.color === color);
                        if (matchingBalls.length > 0) { matchingBalls[0].style.animation = 'bounce 0.5s ease-in-out 3'; setTimeout(() => matchingBalls[0].style.animation = '', 1500); return; }
                    }
                }
                const colorCount2 = {};
                clickableBalls.forEach(ball => { const color = ball.dataset.color; colorCount2[color] = (colorCount2[color] || 0) + 1; });
                let maxColor = '', maxCount = 0;
                for (const color in colorCount2) { if (colorCount2[color] > maxCount) { maxCount = colorCount2[color]; maxColor = color; } }
                if (maxColor) {
                    const matchingBalls = clickableBalls.filter(b => b.dataset.color === maxColor);
                    matchingBalls.slice(0, 2).forEach(ball => { ball.style.animation = 'bounce 0.5s ease-in-out 3'; setTimeout(() => ball.style.animation = '', 1500); });
                }
            }
            updateUI() {
                document.getElementById('levelInfo').textContent = `Á¨¨ ${this.level} ÂÖ≥`;
                document.getElementById('scoreInfo').textContent = `ÂæóÂàÜ: ${this.score}`;
                document.getElementById('levelProgress').textContent = `ÂÖ≥Âç° ${this.level}/${CONFIG.levels.length}`;
                document.getElementById('shuffleCount').textContent = this.tools.shuffle;
                document.getElementById('undoCount').textContent = this.tools.undo;
                document.getElementById('hintCount').textContent = this.tools.hint;
                document.getElementById('shuffleBtn').disabled = this.tools.shuffle <= 0;
                document.getElementById('undoBtn').disabled = this.tools.undo <= 0;
                document.getElementById('hintBtn').disabled = this.tools.hint <= 0;
            }
            restart() { document.getElementById('gameOverModal').classList.remove('show'); this.tools = { shuffle: 3, undo: 3, hint: 3 }; this.score = 0; this.combo = 0; this.startLevel(); }
            nextLevel() { document.getElementById('winModal').classList.remove('show'); this.level++; this.tools = { shuffle: 3, undo: 3, hint: 3 }; this.combo = 0; this.startLevel(); }
        }
        const game = new Game();
        if (typeof window.CrazyGames !== 'undefined') window.CrazyGames.SDK.init();
    </script>
</body>
</html>