<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ball Match 3D v2.7.9</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { font-family: 'Microsoft YaHei', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; overflow: hidden; touch-action: none; }
        #gameContainer { width: 100%; height: 100vh; display: flex; flex-direction: column; position: relative; }
        #topBar { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1)); backdrop-filter: blur(10px); flex-shrink: 0; border-radius: 0 0 20px 20px; margin: 0 10px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        #levelInfo { color: white; font-size: clamp(16px, 4.5vw, 22px); font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); background: linear-gradient(135deg, #FFD700, #FFA500); padding: 6px 16px; border-radius: 20px; box-shadow: 0 3px 10px rgba(255,165,0,0.4); }
        #scoreInfo { color: white; font-size: clamp(14px, 4vw, 18px); font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); background: linear-gradient(135deg, #00cc66, #009944); padding: 6px 16px; border-radius: 20px; box-shadow: 0 3px 10px rgba(0,200,100,0.4); }
        #gameArea { flex: 1; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        #board { position: relative; width: 100%; height: 100%; }
        .ball { position: absolute; border-radius: 50%; cursor: pointer; transition: all 0.2s cubic-bezier(0.68, -0.55, 0.265, 1.55); display: flex; align-items: center; justify-content: center; font-size: clamp(14px, 3.5vw, 20px); box-shadow: inset -3px -3px 8px rgba(255,255,255,0.9), inset 3px 3px 8px rgba(255,255,255,0.5), inset 2px 2px 6px rgba(0,0,0,0.15), 0 6px 12px rgba(0,0,0,0.4), 0 2px 4px rgba(0,0,0,0.3); }
        .ball::before { content: ''; position: absolute; top: 8%; left: 15%; width: 28%; height: 20%; background: radial-gradient(ellipse at center, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 50%, transparent 70%); border-radius: 50%; transform: rotate(-25deg); }
        .ball::after { content: ''; position: absolute; bottom: 12%; right: 18%; width: 18%; height: 12%; background: radial-gradient(ellipse at center, rgba(255,255,255,0.6) 0%, transparent 70%); border-radius: 50%; }
        .ball.clickable { animation: float 2s ease-in-out infinite; }
        .ball.clickable:hover { transform: scale(1.08); filter: brightness(1.15); }
        .ball.blocked { filter: brightness(0.85); cursor: not-allowed; }
        .ball.selected { animation: bounce 0.5s ease-in-out infinite; box-shadow: inset -3px -3px 8px rgba(255,255,255,0.95), inset 3px 3px 8px rgba(255,255,255,0.6), 0 0 25px rgba(255,255,255,0.7), 0 0 0 4px rgba(255,255,255,0.5); }
        .ball[data-color="white"] { box-shadow: inset -3px -3px 8px rgba(255,255,255,1), inset 3px 3px 8px rgba(200,200,200,0.8), inset 2px 2px 6px rgba(0,0,0,0.1), 0 6px 12px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2); }
        .ball[data-color="white"]::before { background: radial-gradient(ellipse at center, rgba(255,255,255,1) 0%, rgba(255,255,255,0.8) 40%, transparent 70%); }
        .ball[data-color="white"]::after { background: radial-gradient(ellipse at center, rgba(255,255,255,0.9) 0%, transparent 70%); }
        .ball.removing { animation: popOut 0.3s ease-out forwards; }
        .ball.hint { animation: hintPulse 0.6s ease-in-out infinite; box-shadow: 0 0 20px #FFD700, 0 0 40px #FFD700; z-index: 1000 !important; }
        @keyframes hintPulse { 0%, 100% { box-shadow: 0 0 20px #FFD700; } 50% { box-shadow: 0 0 40px #FFD700, 0 0 60px #FFD700; } }
        @keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        @keyframes bounce { 0%, 100% { transform: scale(1.05) translateY(0); } 50% { transform: scale(1.1) translateY(-5px); } }
        @keyframes popOut { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.25); opacity: 0.9; } 100% { transform: scale(0); opacity: 0; } }
        #slotArea { height: clamp(85px, 15vh, 120px); background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0.3)); display: flex; align-items: center; justify-content: center; padding: 12px; gap: clamp(6px, 2vw, 12px); position: relative; flex-shrink: 0; border-top: 3px solid rgba(255,255,255,0.2); }
        #slotLabel { position: absolute; left: 50%; top: 5px; transform: translateX(-50%); color: rgba(255,255,255,0.7); font-size: clamp(10px, 3vw, 12px); font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); background: rgba(0,0,0,0.4); padding: 3px 12px; border-radius: 10px; white-space: nowrap; z-index: 10; }
        .slot { border-radius: 50%; background: rgba(255,255,255,0.15); border: 3px dashed rgba(255,215,0,0.5); display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0; box-shadow: inset 0 2px 8px rgba(0,0,0,0.3); min-width: 45px; min-height: 45px; }
        .slot.filled { border: none; background: transparent; }
        #toolsArea { position: absolute; bottom: clamp(85px, 15vh, 110px); left: 50%; transform: translateX(-50%); display: flex; gap: clamp(12px, 3vw, 24px); z-index: 100; background: linear-gradient(145deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05)); padding: 12px 24px; border-radius: 60px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); backdrop-filter: blur(10px); }
        .toolWrapper { display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .toolBtn { width: clamp(56px, 12vw, 72px); height: clamp(56px, 12vw, 72px); border-radius: 50%; border: 3px solid rgba(255,255,255,0.3); background: linear-gradient(145deg, #667eea, #764ba2); color: white; font-size: clamp(22px, 5vw, 30px); cursor: pointer; box-shadow: 0 6px 20px rgba(102,126,234,0.5), inset 0 2px 4px rgba(255,255,255,0.3); transition: all 0.2s; display: flex; align-items: center; justify-content: center; position: relative; }
        .toolBtn:hover { transform: scale(1.15) translateY(-3px); box-shadow: 0 10px 30px rgba(102,126,234,0.7), inset 0 2px 4px rgba(255,255,255,0.4); }
        .toolBtn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; box-shadow: none; }
        .toolCount { position: absolute; top: -6px; right: -6px; background: linear-gradient(145deg, #ff4757, #ff3838); color: white; width: clamp(22px, 5vw, 28px); height: clamp(22px, 5vw, 28px); border-radius: 50%; font-size: clamp(11px, 3vw, 14px); display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 3px 8px rgba(255,71,87,0.5); border: 2px solid white; }
        .toolLabel { color: white; font-size: clamp(11px, 3vw, 13px); font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); background: rgba(0,0,0,0.3); padding: 3px 10px; border-radius: 12px; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; }
        .modal.show { opacity: 1; visibility: visible; }
        .modalContent { background: linear-gradient(145deg, #667eea, #764ba2); padding: clamp(20px, 6vw, 35px); border-radius: 20px; text-align: center; color: white; max-width: min(320px, 85vw); width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5); transform: scale(0.8); transition: transform 0.3s; }
        .modal.show .modalContent { transform: scale(1); }
        .modalTitle { font-size: clamp(20px, 5.5vw, 26px); margin-bottom: 12px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .modalText { font-size: clamp(13px, 3.5vw, 15px); margin-bottom: 22px; opacity: 0.9; }
        .modalBtn { padding: clamp(10px, 3.5vw, 14px) clamp(25px, 7vw, 35px); font-size: clamp(15px, 4vw, 17px); border: none; border-radius: 30px; background: linear-gradient(145deg, #FFD700, #FFA500); color: white; cursor: pointer; font-weight: bold; box-shadow: 0 4px 15px rgba(255, 165, 0, 0.4); transition: all 0.2s; }
        .modalBtn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(255, 165, 0, 0.6); }
        #startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; padding: 20px; }
        #gameTitle { font-size: clamp(28px, 9vw, 44px); color: white; text-shadow: 3px 3px 6px rgba(0,0,0,0.3); margin-bottom: 12px; text-align: center; }
        #gameSubtitle { font-size: clamp(13px, 3.5vw, 16px); color: rgba(255,255,255,0.8); margin-bottom: 35px; text-align: center; }
        .demoBall { width: clamp(50px, 15vw, 70px); height: clamp(50px, 15vw, 70px); border-radius: 50%; margin: clamp(4px, 1.5vw, 8px); display: inline-block; animation: demoBounce 1s ease-in-out infinite; box-shadow: inset -3px -3px 8px rgba(255,255,255,0.9), inset 3px 3px 8px rgba(255,255,255,0.5), 0 6px 12px rgba(0,0,0,0.4); }
        .demoBall:nth-child(2) { animation-delay: 0.1s; }
        .demoBall:nth-child(3) { animation-delay: 0.2s; }
        @keyframes demoBounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }
        #startBtn { padding: clamp(12px, 4vw, 18px) clamp(35px, 10vw, 55px); font-size: clamp(16px, 4.5vw, 22px); border: none; border-radius: 50px; background: linear-gradient(145deg, #FFD700, #FFA500); color: white; cursor: pointer; font-weight: bold; box-shadow: 0 6px 20px rgba(255, 165, 0, 0.4); transition: all 0.3s; margin-top: 35px; }
        #startBtn:hover { transform: scale(1.1); box-shadow: 0 8px 30px rgba(255, 165, 0, 0.6); }
        .particle { position: absolute; width: clamp(5px, 1.5vw, 9px); height: clamp(5px, 1.5vw, 9px); border-radius: 50%; pointer-events: none; animation: particleFade 0.6s ease-out forwards; }
        @keyframes particleFade { 0% { transform: translate(0, 0) scale(1); opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; } }
        #comboText { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(28px, 9vw, 44px); font-weight: bold; color: #FFD700; text-shadow: 3px 3px 6px rgba(0,0,0,0.5); pointer-events: none; opacity: 0; z-index: 500; }
        .comboShow { animation: comboAnim 1s ease-out forwards; }
        @keyframes comboAnim { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 80% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1) translateY(-40px); opacity: 0; } }
        #levelProgress { position: fixed; top: 75px; left: 15px; transform: none; color: white; font-size: clamp(10px, 3vw, 12px); font-weight: bold; background: linear-gradient(135deg, #ff6b6b, #ff8e53); padding: 5px 12px; border-radius: 15px; box-shadow: 0 3px 10px rgba(255,107,107,0.4); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); z-index: 200; border: 2px solid rgba(255,255,255,0.3); }
        #versionDisplay { position: fixed; bottom: 5px; right: 10px; color: rgba(255,255,255,0.4); font-size: 10px; z-index: 100; }
        #soundControls { position: fixed; top: 75px; right: 10px; display: flex; gap: 8px; z-index: 200; }
        .soundBtn { width: 36px; height: 36px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.4); background: linear-gradient(145deg, #667eea, #764ba2); color: white; font-size: 16px; cursor: pointer; box-shadow: 0 4px 12px rgba(102,126,234,0.4); transition: all 0.2s; }
        .soundBtn:hover { transform: scale(1.15); box-shadow: 0 8px 25px rgba(102,126,234,0.7), inset 0 2px 4px rgba(255,255,255,0.4); }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1 id="gameTitle">Ball Match 3D</h1>
        <p id="gameSubtitle">Tap balls to match 3 of the same color</p>
        <div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #ff0000, #cc0000);"></div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #0066ff, #0044cc);"></div>
            <div class="demoBall" style="background: radial-gradient(circle at 30% 30%, #ffcc00, #ff9900);"></div>
        </div>
        <button id="startBtn">START GAME</button>
    </div>

    <div id="gameContainer" style="display: none;">
                                                              <div id="versionDisplay">v2.9.18</div>
        <div id="soundControls">
            <button class="soundBtn" id="clickSoundBtn" title="Sound Effects">ğŸ”Š</button>
            <button class="soundBtn" id="cheerSoundBtn" title="Cheer Effects">ğŸ¶</button>
        </div>
        <div id="topBar">
            <div id="levelInfo">Level 1</div>
            <div id="scoreInfo">Score: 0</div>
        </div>
        <div id="levelProgress">Level 1/15</div>
        <div id="gameArea">
            <div id="board"></div>
        </div>
        <div id="toolsArea">
            <div class="toolWrapper">
                <button class="toolBtn" id="shuffleBtn">ğŸ²<span class="toolCount" id="shuffleCount">3</span></button>
                <span class="toolLabel">Shuffle</span>
            </div>
            <div class="toolWrapper">
                <button class="toolBtn" id="undoBtn">â†©ï¸<span class="toolCount" id="undoCount">3</span></button>
                <span class="toolLabel">Undo</span>
            </div>
            <div class="toolWrapper">
                <button class="toolBtn" id="hintBtn">âœ¨<span class="toolCount" id="hintCount">3</span></button>
                <span class="toolLabel">Hint</span>
            </div>
        </div>
        <div id="slotArea">
            <span id="slotLabel">SLOT</span>
            <div class="slot" data-index="0"></div>
            <div class="slot" data-index="1"></div>
            <div class="slot" data-index="2"></div>
            <div class="slot" data-index="3"></div>
            <div class="slot" data-index="4"></div>
            <div class="slot" data-index="5"></div>
            <div class="slot" data-index="6"></div>
        </div>
    </div>
    <div id="comboText"></div>
    <div id="gameOverModal" class="modal">
        <div class="modalContent">
            <h2 class="modalTitle">Game Over</h2>
            <p class="modalText">Slot is full! Try again.</p>
            <button class="modalBtn" onclick="game.restart()">Play Again</button>
        </div>
    </div>
    <div id="winModal" class="modal">
        <div class="modalContent">
            <h2 class="modalTitle" id="winTitle">Level Complete!</h2>
            <p class="modalText" id="winText">Great job! All balls cleared!</p>
            <button class="modalBtn" id="nextBtn" onclick="game.nextLevel()">Next Level</button>
        </div>
    </div>
    <script>
        class SoundManager {
            constructor() { this.clickEnabled = true; this.cheerEnabled = true; this.audioContext = null; }
            init() { 
                try { 
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); 
                    // Mobile: unlock audio on first touch anywhere
                    const unlockAudio = () => {
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    };
                    document.addEventListener('touchstart', unlockAudio, { once: true });
                    document.addEventListener('click', unlockAudio, { once: true });
                } catch(e) {} 
            }
            playClick() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(800, 0.05, 0.1, 'sine', 0.2); }
            playMatch() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(600, 0.1, 0.15, 'sine', 0.2); setTimeout(() => this.playTone(800, 0.1, 0.15, 'sine', 0.2), 80); setTimeout(() => this.playTone(1000, 0.15, 0.2, 'sine', 0.2), 160); }
            playCheer() { if (!this.cheerEnabled || !this.audioContext) return; [523, 659, 784, 1047, 1319].forEach((f, i) => setTimeout(() => this.playTone(f, 0.1, 0.3, 'triangle', 0.25), i * 100)); }
            playWin() { if (!this.cheerEnabled || !this.audioContext) return; [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => this.playTone(f, 0.15, 0.2, 'triangle', 0.3), i * 120)); }
            playLose() { if (!this.cheerEnabled || !this.audioContext) return; [400, 350, 300, 250].forEach((f, i) => setTimeout(() => this.playTone(f, 0.2, 0.25, 'sawtooth', 0.2), i * 100)); }
            playTool() { if (!this.clickEnabled || !this.audioContext) return; this.playTone(500, 0.08, 0.12, 'square', 0.2); setTimeout(() => this.playTone(700, 0.08, 0.12, 'square', 0.2), 60); }
            playCombo() { if (!this.cheerEnabled || !this.audioContext) return; this.playTone(880, 0.1, 0.15, 'sine', 0.25); }
            playTone(f, a, d, t, v) { 
                if (!this.audioContext) return;
                // Mobile: try to resume if suspended
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                const o = this.audioContext.createOscillator(), g = this.audioContext.createGain(); 
                o.connect(g); 
                g.connect(this.audioContext.destination); 
                o.frequency.value = f; 
                o.type = t; 
                const n = this.audioContext.currentTime; 
                g.gain.setValueAtTime(0, n); 
                g.gain.linearRampToValueAtTime(v, n + a); 
                g.gain.exponentialRampToValueAtTime(0.01, n + a + d); 
                o.start(n); 
                o.stop(n + a + d + 0.05); 
            }
            toggleClick() { return this.clickEnabled = !this.clickEnabled; }
            toggleCheer() { return this.cheerEnabled = !this.cheerEnabled; }
        }
        const CONFIG = {
            slotCount: 7,
            colors: [
                { name: 'red', bg: 'radial-gradient(circle at 30% 30%, #ff0000, #990000)', emoji: 'ğŸ”´' },
                { name: 'blue', bg: 'radial-gradient(circle at 30% 30%, #3388ff, #0044cc)', emoji: 'ğŸ”µ' },
                { name: 'yellow', bg: 'radial-gradient(circle at 30% 30%, #ffdd33, #ff9900)', emoji: 'ğŸŸ¡' },
                { name: 'green', bg: 'radial-gradient(circle at 30% 30%, #00aa00, #006600)', emoji: 'ğŸŸ¢' },
                { name: 'purple', bg: 'radial-gradient(circle at 30% 30%, #aa44ff, #6600cc)', emoji: 'ğŸŸ£' },
                { name: 'white', bg: 'radial-gradient(circle at 30% 30%, #f8f8f8, #d0d0d0)', emoji: 'âšª' },
                { name: 'cyan', bg: 'radial-gradient(circle at 30% 30%, #00ffff, #00aaaa)', emoji: 'ğŸ’' },
                { name: 'pink', bg: 'radial-gradient(circle at 30% 30%, #ff88dd, #cc3399)', emoji: 'ğŸ’—' },
                { name: 'brown', bg: 'radial-gradient(circle at 30% 30%, #8b4513, #5c2e0c)', emoji: 'ğŸŸ¤' },
                { name: 'orange', bg: 'radial-gradient(circle at 30% 30%, #ff6600, #cc4400)', emoji: 'ğŸŠ' },
                { name: 'black', bg: 'radial-gradient(circle at 30% 30%, #444444, #111111)', emoji: 'âš«' },
                { name: 'gold', bg: 'radial-gradient(circle at 30% 30%, #ffd700, #b8860b)', emoji: 'ğŸ†' }
            ],
            levels: [
                { rows: 3, cols: 5, layers: 1, types: 2, name: "First Try" },
                { rows: 3, cols: 5, layers: 1, types: 3, name: "Easy Start" },
                { rows: 3, cols: 5, layers: 2, types: 4, name: "Getting There" },
                { rows: 3, cols: 5, layers: 2, types: 5, name: "Steady Progress" },
                { rows: 4, cols: 6, layers: 2, types: 6, name: "Small Win" },
                { rows: 4, cols: 6, layers: 3, types: 7, name: "Show Time" },
                { rows: 5, cols: 6, layers: 3, types: 8, name: "Challenge Begins" },
                { rows: 5, cols: 6, layers: 4, types: 9, name: "Keep Going" },
                { rows: 5, cols: 6, layers: 4, types: 10, name: "Breakthrough" },
                { rows: 6, cols: 7, layers: 4, types: 11, name: "Halfway" },
                { rows: 6, cols: 7, layers: 5, types: 10, name: "Tough Road" },
                { rows: 6, cols: 7, layers: 5, types: 11, name: "Peak Level" },
                { rows: 6, cols: 7, layers: 6, types: 11, name: "King's Path" },
                { rows: 6, cols: 7, layers: 6, types: 12, name: "Legendary" },
                { rows: 6, cols: 7, layers: 6, types: 12, name: "Ultimate" }
            ]
        };
        class Game {
            constructor() { this.level = 1; this.score = 0; this.balls = []; this.slots = []; this.history = []; this.tools = { shuffle: 3, undo: 3, hint: 3 }; this.isProcessing = false; this.combo = 0; this.lastMatchTime = 0; this.ballSize = 50; this.ballGap = 6; this.soundManager = new SoundManager(); this.hasInteracted = false; this.tutorialElement = null; this.tutorialTimeout = null; this.resizeTimeout = null; this.init(); }
            init() { this.bindEvents(); this.handleResize(); window.addEventListener('resize', () => this.handleResize()); }
            bindEvents() {
                document.getElementById('startBtn').addEventListener('click', () => { 
                    document.getElementById('startScreen').style.display = 'none'; 
                    document.getElementById('gameContainer').style.display = 'flex'; 
                    this.soundManager.init(); 
                    this.soundManager.playClick();
                    CrazySDK.gameStart();
                    this.startLevel(); 
                });
                document.getElementById('shuffleBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('shuffle'); });
                document.getElementById('undoBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('undo'); });
                document.getElementById('hintBtn').addEventListener('click', () => { this.soundManager.playTool(); this.useTool('hint'); });
                document.getElementById('clickSoundBtn').addEventListener('click', (e) => { const on = this.soundManager.toggleClick(); e.target.textContent = on ? 'ğŸ”Š' : 'ğŸ”‡'; e.target.style.opacity = on ? '1' : '0.5'; });
                document.getElementById('cheerSoundBtn').addEventListener('click', (e) => { const on = this.soundManager.toggleCheer(); e.target.textContent = on ? 'ğŸ¶' : 'ğŸ”‡'; e.target.style.opacity = on ? '1' : '0.5'; });
            }
            handleResize() {
                const gameArea = document.getElementById('gameArea');
                const levelConfig = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)];
                
                // æ ¹æ®å±å¹•å®½åº¦åŠ¨æ€è®¡ç®—çƒçš„å¤§å°
                // åç§»è§„åˆ™ï¼šå¶æ•°å±‚åç§»0ï¼Œå¥‡æ•°å±‚åç§»0.5
                // å¥‡æ•°å±‚äº¤æ›¿æ–¹å‘ï¼šç¬¬1å±‚å³+0.5ï¼Œç¬¬3å±‚å·¦-0.5...
                const maxOffset = 0.5; // æœ€å¤§åç§»0.5ä¸ªçƒå¤§å°
                
                if (window.innerWidth < 600) { // ç§»åŠ¨ç«¯åˆ¤æ–­
                    // è®¡ç®—çƒå¤§å°ï¼ŒåŒæ—¶è€ƒè™‘åˆ—æ•°ã€è¡Œæ•°å’Œå±‚åç§»
                    // ç¡®ä¿æ£‹ç›˜åœ¨å®½åº¦å’Œé«˜åº¦ä¸Šéƒ½é€‚åˆå±å¹•
                    const maxColOffsetRatio = 0.35 * 0.5; // ç›¸å¯¹äºçƒå¤§å°çš„åˆ—åç§»æ¯”ä¾‹
                    const maxRowOffsetRatio = 0.35 * 0.5; // ç›¸å¯¹äºçƒå¤§å°çš„è¡Œåç§»æ¯”ä¾‹
                    
                    // è®¡ç®—åŸºäºå®½åº¦çš„çƒå¤§å°
                    const widthSpan = levelConfig.cols + maxColOffsetRatio;
                    const availableWidth = window.innerWidth * 0.92;
                    const sizeByWidth = Math.floor(availableWidth / widthSpan);
                    
                    // è®¡ç®—åŸºäºé«˜åº¦çš„çƒå¤§å°ï¼ˆè€ƒè™‘å·¥å…·æ å’Œæ§½ä½åŒºåŸŸï¼‰
                    const gameAreaHeight = window.innerHeight * 0.65; // æ¸¸æˆåŒºåŸŸå¤§çº¦å å±å¹•65%
                    const heightSpan = levelConfig.rows + maxRowOffsetRatio;
                    const sizeByHeight = Math.floor(gameAreaHeight / heightSpan);
                    
                    // å–è¾ƒå°å€¼ç¡®ä¿æ£‹ç›˜èƒ½å®Œæ•´æ˜¾ç¤º
                    this.ballSize = Math.min(sizeByWidth, sizeByHeight);
                    this.ballSize = Math.max(this.ballSize, 28); // æœ€å°28px
                    this.ballSize = Math.min(this.ballSize, 45); // æœ€å¤§45px
                    this.ballGap = 2;
                } else {
                    const sizeByWidth = Math.floor(gameArea.clientWidth * 0.95 / (levelConfig.cols + levelConfig.layers * 0.15));
                    const sizeByHeight = Math.floor(gameArea.clientHeight * 0.9 / (levelConfig.rows + levelConfig.layers * 0.15));
                    this.ballSize = Math.max(42, Math.min(65, Math.min(sizeByWidth, sizeByHeight)));
                    this.ballGap = Math.max(3, Math.floor(this.ballSize / 12));
                }
                
                document.querySelectorAll('.slot').forEach(slot => { slot.style.width = this.ballSize + 'px'; slot.style.height = this.ballSize + 'px'; });
                // ä½¿ç”¨é˜²æŠ–é¿å…é¢‘ç¹é‡æ–°æ¸²æŸ“
                if (this.resizeTimeout) clearTimeout(this.resizeTimeout);
                if (this.balls.length > 0 && document.getElementById('gameContainer').style.display !== 'none' && !this.isProcessing) {
                    this.resizeTimeout = setTimeout(() => {
                        requestAnimationFrame(() => this.regenerateBoardWithNewSize());
                    }, 200);
                }
            }
            regenerateBoardWithNewSize() {
                // ä¿å­˜å½“å‰æ£‹ç›˜çŠ¶æ€ï¼ˆé¢œè‰²ã€ä½ç½®ã€æ§½ä½çŠ¶æ€ï¼‰
                const boardState = this.balls.map(ball => ({
                    id: ball.dataset.id,
                    color: ball.dataset.color,
                    layer: parseInt(ball.dataset.layer),
                    row: parseInt(ball.dataset.row),
                    col: parseInt(ball.dataset.col),
                    inSlot: this.slots.includes(ball)
                }));
                const slotColors = this.slots.map(ball => ball.dataset.color);
                
                // é‡æ–°ç”Ÿæˆæ£‹ç›˜ï¼ˆæ–°å°ºå¯¸ï¼‰
                const config = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)];
                this.generateBoardWithState(config, boardState, slotColors);
            }
            generateBoardWithState(config, boardState, slotColors) {
                this.balls = []; 
                const board = document.getElementById('board'); 
                // ä¿ç•™æ§½ä½ä¸­çš„çƒ
                this.slots = [];
                
                const gameArea = document.getElementById('gameArea');
                const ballTotalSize = this.ballSize + this.ballGap;
                const layerOffset = this.ballSize * 0.35;
                
                // è®¡ç®—å®é™…æ£‹ç›˜å°ºå¯¸ï¼ˆè€ƒè™‘å±‚åç§»ï¼‰
                // å¥‡æ•°å±‚å‘å³åç§»ï¼Œéœ€è¦é¢å¤–ç©ºé—´
                const maxColOffset = layerOffset * 0.5; // æœ€å¤§åˆ—åç§»
                
                // è€ƒè™‘å·¦å³åç§»åçš„å®é™…å®½åº¦
                // æœ€å·¦è¾¹çš„çƒåœ¨å¶æ•°å±‚ï¼ˆåç§»0ï¼‰ï¼Œæœ€å³è¾¹çš„çƒåœ¨å¥‡æ•°å±‚ï¼ˆå‘å³åç§»ï¼‰
                const boardWidth = config.cols * ballTotalSize + maxColOffset;
                const boardHeight = config.rows * ballTotalSize + maxColOffset;
                
                // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å°çš„è¾¹è·ï¼Œç¡®ä¿æ£‹ç›˜ä¸æº¢å‡º
                const isMobile = window.innerWidth < 600;
                const minMargin = isMobile ? 2 : 5;
                const offsetX = Math.max(minMargin, (gameArea.clientWidth - boardWidth) / 2);
                const offsetY = Math.max(minMargin, (gameArea.clientHeight - boardHeight) / 2);
                
                // æŒ‰å±‚ã€è¡Œã€åˆ—é‡æ–°åˆ›å»ºçƒ
                let slotIndex = 0;
                for (let layer = 0; layer < config.layers; layer++) {
                    for (let row = 0; row < config.rows; row++) {
                        for (let col = 0; col < config.cols; col++) {
                            // æŸ¥æ‰¾å¯¹åº”ä½ç½®çš„çƒçŠ¶æ€
                            const savedBall = boardState.find(b => b.layer === layer && b.row === row && b.col === col);
                            if (!savedBall) continue;
                            
                            const ball = document.createElement('div');
                            ball.className = 'ball';
                            ball.style.width = this.ballSize + 'px';
                            ball.style.height = this.ballSize + 'px';
                            
                            // äº¤æ›¿æ–¹å‘åç§»
                            const offset = (layer % 2 === 1) ? layerOffset * 0.5 : 0;
                            const direction = (Math.floor(layer / 2) % 2 === 0) ? 1 : -1;
                            const finalOffset = offset * direction;
                            ball.style.left = (offsetX + col * ballTotalSize + finalOffset) + 'px';
                            ball.style.top = (offsetY + row * ballTotalSize + finalOffset) + 'px';
                            
                            ball.dataset.originalLeft = ball.style.left;
                            ball.dataset.originalTop = ball.style.top;
                            
                            // æ¢å¤é¢œè‰²
                            const colorData = CONFIG.colors.find(c => c.name === savedBall.color);
                            ball.style.background = colorData.bg;
                            ball.style.zIndex = layer + 1;
                            ball.dataset.color = savedBall.color;
                            ball.dataset.id = savedBall.id;
                            ball.dataset.layer = layer;
                            ball.dataset.row = row;
                            ball.dataset.col = col;
                            ball.textContent = window.innerWidth < 600 ? (['cyan', 'pink', 'orange', 'gold'].includes(savedBall.color) ? colorData.emoji : '') : colorData.emoji;
                            
                            ball.addEventListener('click', (e) => this.onBallClick(e, ball));
                            
                            if (savedBall.inSlot && slotIndex < slotColors.length) {
                                // çƒåœ¨æ§½ä½ä¸­
                                this.slots.push(ball);
                                slotIndex++;
                            } else {
                                board.appendChild(ball);
                            }
                            this.balls.push(ball);
                        }
                    }
                }
                
                this.updateSlots();
                this.updateClickable();
            }
            startLevel() { this.generateBoard(CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)]); this.updateUI(); this.showTutorialIfNeeded(); }
            showTutorialIfNeeded() {
                if (this.level === 1 && !this.hasInteracted) {
                    this.tutorialTimeout = setTimeout(() => {
                        this.showTutorial();
                    }, 5000);
                }
            }
            showTutorial() {
                const tutorial = document.createElement('div');
                tutorial.id = 'tutorialTip';
                tutorial.style.cssText = 'position:fixed;top:30%;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#FFD700,#FFA500);color:white;padding:16px 24px;border-radius:16px;font-size:16px;font-weight:bold;z-index:3000;box-shadow:0 8px 32px rgba(0,0,0,0.4);text-align:center;max-width:80%;animation:fadeIn 0.5s ease;cursor:pointer;';
                tutorial.innerHTML = 'ğŸ’¡ Tap balls of the same color to match 3.<br>Watch out - don\'t fill up the slot!<br><span style="font-size:12px;opacity:0.8;">(Tap anywhere to close)</span>';
                document.body.appendChild(tutorial);
                this.tutorialElement = tutorial;
                
                // Close on any click/tap
                const closeTutorial = () => {
                    this.hideTutorial();
                    document.removeEventListener('click', closeTutorial);
                    document.removeEventListener('touchstart', closeTutorial);
                };
                setTimeout(() => {
                    document.addEventListener('click', closeTutorial);
                    document.addEventListener('touchstart', closeTutorial);
                }, 100);
            }
            hideTutorial() {
                if (this.tutorialElement) {
                    this.tutorialElement.remove();
                    this.tutorialElement = null;
                }
                if (this.tutorialTimeout) {
                    clearTimeout(this.tutorialTimeout);
                    this.tutorialTimeout = null;
                }
            }
            generateBoard(config) {
                this.balls = []; this.slots = []; this.history = []; this.updateSlots();
                const board = document.getElementById('board'); board.innerHTML = '';
                const totalBalls = config.rows * config.cols * config.layers;
                const usableBalls = Math.floor(totalBalls / 3) * 3;
                const colors = CONFIG.colors.slice(0, config.types);
                
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æœ‰è¶³å¤Ÿçš„é¢œè‰²
                if (colors.length === 0) {
                    console.error('No colors available');
                    return;
                }
                
                const ballData = [];
                const baseCount = Math.max(0, Math.floor(usableBalls / colors.length / 3) * 3);
                let remaining = usableBalls;
                colors.forEach(color => { for (let i = 0; i < baseCount; i++) ballData.push({ ...color, id: Math.random().toString(36).substr(2, 9) }); remaining -= baseCount; });
                let colorIdx = 0;
                while (remaining >= 3) {
                    const color = colors[colorIdx % colors.length];
                    for (let i = 0; i < 3; i++) ballData.push({ ...color, id: Math.random().toString(36).substr(2, 9) });
                    remaining -= 3; colorIdx++;
                }
                for (let i = ballData.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [ballData[i], ballData[j]] = [ballData[j], ballData[i]]; }
                const gameArea = document.getElementById('gameArea');
                const ballTotalSize = this.ballSize + this.ballGap;
                const layerOffset = this.ballSize * 0.35;
                
                // è®¡ç®—å±…ä¸­åç§»ï¼Œè€ƒè™‘å¥‡æ•°å±‚å‘å³åç§»
                const maxColOffset = layerOffset * 0.5;
                const boardWidth = config.cols * ballTotalSize + maxColOffset;
                const boardHeight = config.rows * ballTotalSize + maxColOffset;
                
                // ç§»åŠ¨ç«¯ä½¿ç”¨æ›´å°çš„è¾¹è·ï¼Œç¡®ä¿æ£‹ç›˜ä¸æº¢å‡º
                const isMobile = window.innerWidth < 600;
                const minMargin = isMobile ? 2 : 10;
                const offsetX = Math.max(minMargin, (gameArea.clientWidth - boardWidth) / 2);
                const offsetY = Math.max(minMargin, (gameArea.clientHeight - boardHeight) / 2);
                let ballIndex = 0;
                for (let layer = 0; layer < config.layers; layer++) {
                    for (let row = 0; row < config.rows; row++) {
                        for (let col = 0; col < config.cols; col++) {
                            if (ballIndex >= usableBalls) break;
                            const ball = document.createElement('div');
                            ball.className = 'ball';
                            ball.style.width = this.ballSize + 'px';
                            ball.style.height = this.ballSize + 'px';
                            // äº¤æ›¿æ–¹å‘åç§»ï¼šå¶æ•°å±‚ä¸åç§»ï¼Œå¥‡æ•°å±‚åç§»0.5
                            const offset = (layer % 2 === 1) ? layerOffset * 0.5 : 0;
                            // å¥‡æ•°å±‚äº¤æ›¿å·¦å³æ–¹å‘ï¼šç¬¬1å±‚å‘å³ï¼Œç¬¬3å±‚å‘å·¦ï¼Œç¬¬5å±‚å‘å³...
                            const direction = (Math.floor(layer / 2) % 2 === 0) ? 1 : -1;
                            const finalOffset = offset * direction;
                            ball.style.left = (offsetX + col * ballTotalSize + finalOffset) + 'px';
                            ball.style.top = (offsetY + row * ballTotalSize + finalOffset) + 'px';
                            ball.dataset.originalLeft = ball.style.left;
                            ball.dataset.originalTop = ball.style.top;
                            ball.style.background = ballData[ballIndex].bg;
                            ball.style.zIndex = layer + 1;
                            ball.dataset.color = ballData[ballIndex].name;
                            ball.dataset.id = ballData[ballIndex].id;
                            ball.dataset.layer = layer;
                            ball.dataset.row = row;
                            ball.dataset.col = col;
                            ball.textContent = window.innerWidth < 600 ? (['cyan', 'pink', 'orange', 'gold'].includes(ballData[ballIndex].name) ? ballData[ballIndex].emoji : '') : ballData[ballIndex].emoji;
                            ball.addEventListener('click', (e) => this.onBallClick(e, ball));
                            board.appendChild(ball); this.balls.push(ball); ballIndex++;
                        }
                    }
                }
                this.updateClickable();
            }
            updateClickable() {
                // æ‰¾åˆ°å½“å‰æœ€é¡¶å±‚ï¼ˆæœ‰çƒä¸”æœªè¢«æ¶ˆé™¤çš„æœ€é«˜å±‚ï¼‰
                let topLayer = 0;
                this.balls.forEach(ball => {
                    if (!ball.classList.contains('removing') && !this.slots.includes(ball)) {
                        topLayer = Math.max(topLayer, parseInt(ball.dataset.layer));
                    }
                });
                
                this.balls.forEach(ball => {
                    const layer = parseInt(ball.dataset.layer);
                    const isBlocked = this.isBallBlocked(ball);
                    
                    if (this.slots.includes(ball)) {
                        // æ§½ä½ä¸­çš„çƒ
                        ball.classList.remove('blocked');
                        ball.classList.remove('clickable');
                    } else if (isBlocked) {
                        // è¢«é˜»æŒ¡çš„çƒ - æ ¹æ®ä¸é¡¶å±‚çš„å…³ç³»å†³å®šæ˜¾ç¤º
                        const layerDiff = layer - topLayer;
                        if (layerDiff === -1) {
                            // ç´§é‚»é¡¶å±‚ä¸‹æ–¹ï¼ˆä¸‹ä¸€å±‚ï¼‰- åŠé€æ˜æ˜¾ç¤º
                            ball.classList.add('blocked');
                            ball.classList.remove('clickable');
                            ball.style.opacity = '0.4';
                            ball.style.visibility = 'visible';
                        } else {
                            // æ›´æ·±å±‚ - å®Œå…¨éšè—
                            ball.classList.add('blocked');
                            ball.classList.remove('clickable');
                            ball.style.opacity = '0';
                            ball.style.visibility = 'hidden';
                        }
                    } else {
                        // å¯ç‚¹å‡»çš„çƒï¼ˆå½“å‰é¡¶å±‚ï¼‰- å®Œå…¨å¯è§
                        ball.classList.remove('blocked');
                        ball.classList.add('clickable');
                        ball.style.opacity = '1';
                        ball.style.visibility = 'visible';
                    }
                });
            }
            isBallBlocked(ball) {
                if (this.slots.includes(ball)) return false;
                const layer = parseInt(ball.dataset.layer);
                const row = parseInt(ball.dataset.row);
                const col = parseInt(ball.dataset.col);
                const nextLayer = layer + 1;
                
                const maxLayers = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)].layers;
                if (nextLayer >= maxLayers) {
                    return false;
                }
                
                // ä½¿ç”¨ for å¾ªç¯ä»£æ›¿ filter æé«˜æ€§èƒ½
                for (const b of this.balls) {
                    if (parseInt(b.dataset.layer) === nextLayer && 
                        !b.classList.contains('removing') && 
                        !this.slots.includes(b) && 
                        Math.abs(parseInt(b.dataset.row) - row) <= 1 && 
                        Math.abs(parseInt(b.dataset.col) - col) <= 1) {
                        return true;
                    }
                }
                return false;
            }
            onBallClick(e, ball) {
                if (this.isProcessing || ball.classList.contains('blocked') || ball.classList.contains('removing') || this.slots.length >= CONFIG.slotCount) return;
                this.hasInteracted = true;
                this.hideTutorial();
                this.soundManager.playClick();
                this.history.push({ balls: this.balls.map(b => ({ id: b.dataset.id, inSlot: this.slots.includes(b), slotIndex: this.slots.indexOf(b), left: b.style.left, top: b.style.top })), slots: [...this.slots], score: this.score });
                this.slots.push(ball); this.updateSlots();
                ball.classList.add('selected'); ball.style.position = 'relative'; ball.style.left = '0'; ball.style.top = '0';
                this.checkMatch(); this.updateClickable(); setTimeout(() => this.checkGameState(), 300);
            }
            updateSlots() {
                document.querySelectorAll('.slot').forEach((slot, index) => {
                    slot.innerHTML = ''; slot.classList.remove('filled');
                    if (this.slots[index]) { const ball = this.slots[index]; ball.classList.remove('selected'); ball.style.width = this.ballSize + 'px'; ball.style.height = this.ballSize + 'px'; slot.appendChild(ball); slot.classList.add('filled'); }
                });
            }
            checkMatch() {
                const colorCount = {};
                this.slots.forEach((ball, index) => { const color = ball.dataset.color; if (!colorCount[color]) colorCount[color] = []; colorCount[color].push(index); });
                for (const color in colorCount) { if (colorCount[color].length >= 3) { this.removeBalls(colorCount[color]); return; } }
            }
            removeBalls(indices) {
                this.isProcessing = true;
                const now = Date.now();
                if (now - this.lastMatchTime < 3000) this.combo++; else this.combo = 1;
                this.lastMatchTime = now;
                if (this.combo > 1) { this.showCombo(this.combo); this.soundManager.playCombo(); }
                else { this.soundManager.playMatch(); }
                this.score += (100 + (this.combo - 1) * 50) * indices.length;
                indices.forEach(index => this.createParticles(this.slots[index]));
                setTimeout(() => {
                    indices.sort((a, b) => b - a).forEach(index => {
                        const ball = this.slots[index]; ball.classList.add('removing');
                        setTimeout(() => { ball.remove(); this.balls = this.balls.filter(b => b !== ball); }, 300);
                        this.slots.splice(index, 1);
                    });
                    this.updateSlots(); this.updateUI(); this.isProcessing = false; setTimeout(() => this.checkWin(), 400);
                }, 100);
            }
            createParticles(ball) {
                const rect = ball.getBoundingClientRect();
                const bg = CONFIG.colors.find(c => c.name === ball.dataset.color)?.bg || '#fff';
                for (let i = 0; i < 8; i++) {
                    const p = document.createElement('div'); p.className = 'particle';
                    p.style.left = (rect.left + rect.width / 2) + 'px'; p.style.top = (rect.top + rect.height / 2) + 'px'; p.style.background = bg;
                    const angle = (i / 8) * Math.PI * 2;
                    p.style.setProperty('--tx', Math.cos(angle) * (40 + Math.random() * 40) + 'px');
                    p.style.setProperty('--ty', Math.sin(angle) * (40 + Math.random() * 40) + 'px');
                    document.body.appendChild(p); setTimeout(() => p.remove(), 600);
                }
            }
            showCombo(combo) {
                const texts = ['', 'COMBO!', 'DOUBLE COMBO!', 'TRIPLE COMBO!', 'AMAZING!', 'LEGENDARY!'];
                const comboText = document.getElementById('comboText');
                comboText.textContent = texts[Math.min(combo, texts.length - 1)];
                comboText.classList.remove('comboShow'); void comboText.offsetWidth; comboText.classList.add('comboShow');
            }
            checkGameState() { 
                if (this.slots.length >= CONFIG.slotCount) { 
                    this.soundManager.playLose(); 
                    CrazySDK.gameEnd();
                    this.showRevivePrompt();
                } 
            }
            showRevivePrompt() {
                // ç§»é™¤å·²å­˜åœ¨çš„å¼¹çª—ï¼Œé˜²æ­¢é‡å¤
                const existingModal = document.getElementById('reviveModal');
                if (existingModal) existingModal.remove();
                
                const modal = document.createElement('div');
                modal.id = 'reviveModal';
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:3000;';
                modal.innerHTML = `
                    <div style="background:linear-gradient(145deg,#ff6b6b,#ee5a5a);padding:35px;border-radius:25px;text-align:center;color:white;max-width:320px;box-shadow:0 20px 60px rgba(0,0,0,0.5);">
                        <h3 style="margin-bottom:15px;font-size:26px;text-shadow:2px 2px 4px rgba(0,0,0,0.3);">ğŸ’€ Game Over!</h3>
                        <p style="margin-bottom:25px;opacity:0.95;font-size:16px;">Watch an ad to continue<br>from where you left off</p>
                        <div style="display:flex;flex-direction:column;gap:12px;">
                            <button id="reviveBtn" style="padding:14px 28px;border:none;border-radius:25px;background:linear-gradient(145deg,#00cc66,#009944);color:white;font-weight:bold;cursor:pointer;box-shadow:0 4px 15px rgba(0,200,100,0.4);font-size:16px;">ğŸ“º Watch Ad & Continue</button>
                            <button id="giveUpBtn" style="padding:12px 24px;border:none;border-radius:25px;background:rgba(255,255,255,0.2);color:white;cursor:pointer;font-size:14px;">Give Up</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // ä½¿ç”¨ä¸€æ¬¡æ€§äº‹ä»¶ç›‘å¬å™¨
                const reviveBtn = modal.querySelector('#reviveBtn');
                const giveUpBtn = modal.querySelector('#giveUpBtn');
                
                reviveBtn.addEventListener('click', function onRevive() {
                    modal.remove();
                    CrazySDK.requestAd(() => {
                        // Revive: è®¡ç®—æ‰€æœ‰çƒï¼ˆæ£‹ç›˜+æ§½ä½ï¼‰ä¸­æ¯ç§é¢œè‰²çš„æ•°é‡
                        const allBalls = [...this.balls, ...this.slots];
                        const colorCount = {};
                        allBalls.forEach(ball => {
                            const color = ball.dataset.color;
                            colorCount[color] = (colorCount[color] || 0) + 1;
                        });
                        
                        // è®¡ç®—éœ€è¦ä»æ§½ä½ç§»é™¤å¤šå°‘çƒï¼Œä½¿å¾—æ¯ç§é¢œè‰²æ€»æ•°æ˜¯3çš„å€æ•°
                        // ä¼˜å…ˆç§»é™¤é‚£äº›æ•°é‡ä¸æ˜¯3çš„å€æ•°çš„é¢œè‰²
                        const slotBallsToRemove = [];
                        const slotColors = [...this.slots];
                        
                        for (const ball of slotColors) {
                            const color = ball.dataset.color;
                            // å¦‚æœç§»é™¤è¿™ä¸ªçƒåï¼Œè¯¥é¢œè‰²æ€»æ•°ä»æ˜¯3çš„å€æ•°æˆ–æ›´æ¥è¿‘3çš„å€æ•°
                            if (colorCount[color] % 3 !== 0) {
                                slotBallsToRemove.push(ball);
                                colorCount[color]--;
                            } else if (slotBallsToRemove.length < Math.floor(this.slots.length / 2)) {
                                // å¦‚æœè¯¥é¢œè‰²å·²ç»æ˜¯3çš„å€æ•°ï¼Œä½†è¿˜éœ€è¦ç§»é™¤æ›´å¤šçƒ
                                slotBallsToRemove.push(ball);
                                colorCount[color]--;
                            }
                        }
                        
                        // å¦‚æœè¿˜æ²¡æœ‰ç§»é™¤å¤Ÿä¸€åŠï¼Œç»§ç»­ç§»é™¤
                        let safetyCounter = 0;
                        while (slotBallsToRemove.length < Math.floor(this.slots.length / 2) && this.slots.length > 0 && safetyCounter < 20) {
                            const ball = this.slots[this.slots.length - 1];
                            if (!slotBallsToRemove.includes(ball)) {
                                slotBallsToRemove.push(ball);
                            }
                            safetyCounter++;
                        }
                        
                        // æ‰§è¡Œç§»é™¤
                        for (const ball of slotBallsToRemove) {
                            const idx = this.slots.indexOf(ball);
                            if (idx > -1) {
                                this.slots.splice(idx, 1);
                                ball.classList.remove('selected');
                                ball.style.position = 'absolute';
                                ball.style.left = ball.dataset.originalLeft || '0px';
                                ball.style.top = ball.dataset.originalTop || '0px';
                                document.getElementById('board').appendChild(ball);
                            }
                        }
                        
                        this.updateSlots();
                        this.updateClickable();
                        CrazySDK.gameStart();
                        this.showComboText('Revived!', '#00cc66');
                    });
                }.bind(this), { once: true });
                
                giveUpBtn.addEventListener('click', function onGiveUp() {
                    modal.remove();
                    document.getElementById('gameOverModal').classList.add('show');
                }.bind(this), { once: true });
            }
            checkWin() {
                if (this.balls.length === 0) {
                    this.soundManager.playWin();
                    const levelConfig = CONFIG.levels[Math.min(this.level - 1, CONFIG.levels.length - 1)];
                    const nextBtn = document.getElementById('nextBtn');
                    
                    // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
                    const newNextBtn = nextBtn.cloneNode(true);
                    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
                    
                    if (this.level >= CONFIG.levels.length) {
                        document.getElementById('winTitle').textContent = 'ğŸ‰ All 15 Levels Cleared!';
                        document.getElementById('winText').textContent = `Final Score: ${this.score}`;
                        newNextBtn.textContent = 'Restart';
                        newNextBtn.onclick = () => { 
                            this.level = 1; 
                            this.score = 0; 
                            document.getElementById('winModal').classList.remove('show'); 
                            this.startLevel(); 
                        };
                    } else {
                        document.getElementById('winTitle').textContent = `Level ${this.level} Complete!`;
                        document.getElementById('winText').textContent = `Level: ${levelConfig.name} | Score: ${this.score}`;
                        newNextBtn.textContent = 'Next Level';
                        newNextBtn.onclick = () => {
                            document.getElementById('winModal').classList.remove('show');
                            this.nextLevel();
                        };
                    }
                    document.getElementById('winModal').classList.add('show');
                }
            }
            useTool(type) { 
                if (this.tools[type] <= 0) {
                    this.showToolAdPrompt(type);
                    return;
                }
                switch(type) { 
                    case 'shuffle': this.shuffleBalls(); break; 
                    case 'undo': this.undo(); break; 
                    case 'hint': this.showHint(); break; 
                } 
                this.tools[type]--; 
                this.updateUI(); 
            }
            showToolAdPrompt(toolType) {
                const toolNames = { shuffle: 'Shuffle', undo: 'Undo', hint: 'Hint' };
                const toolName = toolNames[toolType];
                
                // Create prompt modal
                const modal = document.createElement('div');
                modal.id = 'adPromptModal';
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:3000;';
                modal.innerHTML = `
                    <div style="background:linear-gradient(145deg,#667eea,#764ba2);padding:30px;border-radius:20px;text-align:center;color:white;max-width:300px;box-shadow:0 20px 60px rgba(0,0,0,0.5);">
                        <h3 style="margin-bottom:15px;font-size:22px;">âš¡ ${toolName} Used Up!</h3>
                        <p style="margin-bottom:20px;opacity:0.9;">Watch a short ad to get +1 ${toolName}</p>
                        <div style="display:flex;gap:10px;justify-content:center;">
                            <button id="watchAdBtn" style="padding:12px 24px;border:none;border-radius:25px;background:linear-gradient(145deg,#FFD700,#FFA500);color:white;font-weight:bold;cursor:pointer;box-shadow:0 4px 15px rgba(255,165,0,0.4);">Watch Ad</button>
                            <button id="cancelAdBtn" style="padding:12px 24px;border:none;border-radius:25px;background:rgba(255,255,255,0.2);color:white;cursor:pointer;">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                document.getElementById('watchAdBtn').addEventListener('click', () => {
                    modal.remove();
                    CrazySDK.requestAd(() => {
                        this.tools[toolType]++;
                        this.updateUI();
                        this.showComboText(`+1 ${toolName}!`, '#FFD700');
                    });
                });
                
                document.getElementById('cancelAdBtn').addEventListener('click', () => {
                    modal.remove();
                });
            }
            shuffleBalls() {
                // è·å–æ‰€æœ‰åœ¨æ£‹ç›˜ä¸Šçš„çƒï¼ˆä¸åŒ…æ‹¬æ§½ä½ä¸­çš„ï¼‰
                const boardBalls = this.balls.filter(b => !this.slots.includes(b));
                // æ”¶é›†æ‰€æœ‰é¢œè‰²
                const colors = boardBalls.map(b => b.dataset.color);
                // æ‰“ä¹±é¢œè‰²æ•°ç»„
                for (let i = colors.length - 1; i > 0; i--) { 
                    const j = Math.floor(Math.random() * (i + 1)); 
                    [colors[i], colors[j]] = [colors[j], colors[i]]; 
                }
                // é‡æ–°åˆ†é…é¢œè‰²ï¼Œä¿æŒæ•°é‡ä¸å˜
                boardBalls.forEach((ball, index) => { 
                    const colorData = CONFIG.colors.find(c => c.name === colors[index]); 
                    ball.dataset.color = colors[index]; 
                    ball.style.background = colorData.bg; 
                    ball.textContent = window.innerWidth < 600 ? (['cyan', 'pink', 'orange', 'gold'].includes(colorData.name) ? colorData.emoji : '') : colorData.emoji; 
                });
            }
            undo() {
                if (this.history.length === 0) return;
                const lastState = this.history.pop();
                const board = document.getElementById('board');
                // Restore balls to their positions
                this.balls.forEach(ball => {
                    const savedBall = lastState.balls.find(b => b.id === ball.dataset.id);
                    if (savedBall) {
                        if (savedBall.inSlot) {
                            // Ball was in slot, keep it there
                            if (!this.slots.includes(ball)) this.slots.push(ball);
                        } else {
                            // Ball was on board, remove from slot if present
                            const slotIndex = this.slots.indexOf(ball);
                            if (slotIndex > -1) this.slots.splice(slotIndex, 1);
                            // Move ball back to board if it's in a slot
                            if (ball.parentElement && ball.parentElement.classList.contains('slot')) {
                                board.appendChild(ball);
                            }
                            // Restore position
                            ball.style.position = 'absolute';
                            ball.style.left = savedBall.left;
                            ball.style.top = savedBall.top;
                            ball.style.width = this.ballSize + 'px';
                            ball.style.height = this.ballSize + 'px';
                            ball.classList.remove('selected');
                        }
                    }
                });
                this.updateSlots();
                this.updateClickable();
                this.score = lastState.score;
                this.updateUI();
            }
            showHint() {
                // åªè·å–å®é™…å¯è§çš„å¯ç‚¹å‡»çƒï¼ˆæ²¡æœ‰è¢«æ·±å±‚å®Œå…¨éšè—çš„ï¼‰
                const clickableBalls = this.balls.filter(b => 
                    !b.classList.contains('blocked') && 
                    !this.slots.includes(b) && 
                    !b.classList.contains('removing') &&
                    b.style.visibility !== 'hidden'  // åªæç¤ºå®é™…å¯è§çš„çƒ
                );
                
                // å¦‚æœæ²¡æœ‰å¯è§çš„å¯ç‚¹å‡»çƒï¼Œç›´æ¥æ‰“ä¹±
                if (clickableBalls.length === 0) {
                    this.shuffleBalls();
                    this.showComboText('Auto Shuffle!', '#FFD700');
                    return;
                }
                
                // ç»Ÿè®¡æ§½ä½ä¸­å„é¢œè‰²æ•°é‡
                const slotColorCount = {};
                this.slots.forEach(ball => { 
                    const color = ball.dataset.color; 
                    slotColorCount[color] = (slotColorCount[color] || 0) + 1; 
                });
                
                // 1. ä¼˜å…ˆï¼šæ§½ä½æœ‰2ä¸ªåŒè‰²ï¼Œæ‰¾ç¬¬3ä¸ªå¯è§çš„å¯ç‚¹å‡»çƒ
                for (const color in slotColorCount) {
                    if (slotColorCount[color] >= 2) {
                        const matchingBalls = clickableBalls.filter(b => b.dataset.color === color);
                        if (matchingBalls.length > 0) { 
                            matchingBalls[0].classList.add('hint'); 
                            setTimeout(() => matchingBalls[0].classList.remove('hint'), 2000); 
                            return; 
                        }
                    }
                }
                
                // 2. å…¶æ¬¡ï¼šæ§½ä½æœ‰1ä¸ªï¼Œæ‰¾å¦å¤–2ä¸ªå¯è§çš„åŒè‰²çƒ
                for (const color in slotColorCount) {
                    if (slotColorCount[color] === 1) {
                        const matchingBalls = clickableBalls.filter(b => b.dataset.color === color);
                        if (matchingBalls.length >= 2) { 
                            matchingBalls.slice(0, 2).forEach(ball => { 
                                ball.classList.add('hint'); 
                            });
                            setTimeout(() => {
                                matchingBalls.slice(0, 2).forEach(ball => ball.classList.remove('hint')); 
                            }, 2000); 
                            return; 
                        }
                    }
                }
                
                // 3. æœ€åï¼šæ‰¾å¯è§çš„3ä¸ªåŒè‰²çƒ
                const clickableColorCount = {};
                clickableBalls.forEach(ball => { 
                    const color = ball.dataset.color; 
                    clickableColorCount[color] = (clickableColorCount[color] || 0) + 1; 
                });
                
                for (const color in clickableColorCount) {
                    if (clickableColorCount[color] >= 3) {
                        const matchingBalls = clickableBalls.filter(b => b.dataset.color === color);
                        matchingBalls.slice(0, 3).forEach(ball => { 
                            ball.classList.add('hint'); 
                        });
                        setTimeout(() => {
                            matchingBalls.slice(0, 3).forEach(ball => ball.classList.remove('hint')); 
                        }, 2000); 
                        return;
                    }
                }
                
                // 4. æ²¡æœ‰å¯è§çš„å¯æ¶ˆé™¤ç»„åˆï¼Œè‡ªåŠ¨æ‰“ä¹±
                this.shuffleBalls();
                this.showComboText('Auto Shuffle!', '#FFD700');
            }
            
            showComboText(text, color) {
                const comboText = document.getElementById('comboText');
                comboText.textContent = text;
                comboText.style.color = color;
                comboText.classList.add('comboShow');
                setTimeout(() => comboText.classList.remove('comboShow'), 1000);
            }
            updateUI() {
                document.getElementById('levelInfo').textContent = `Level ${this.level}`;
                document.getElementById('scoreInfo').textContent = `Score: ${this.score}`;
                document.getElementById('levelProgress').textContent = `Level ${this.level}/${CONFIG.levels.length}`;
                document.getElementById('shuffleCount').textContent = this.tools.shuffle;
                document.getElementById('undoCount').textContent = this.tools.undo;
                document.getElementById('hintCount').textContent = this.tools.hint;
                document.getElementById('shuffleBtn').disabled = this.tools.shuffle <= 0;
                document.getElementById('undoBtn').disabled = this.tools.undo <= 0;
                document.getElementById('hintBtn').disabled = this.tools.hint <= 0;
            }
            restart() { 
                document.getElementById('gameOverModal').classList.remove('show'); 
                this.tools = { shuffle: 3, undo: 3, hint: 3 }; 
                this.score = 0; 
                this.combo = 0; 
                this.hasInteracted = false; 
                this.hideTutorial(); 
                CrazySDK.gameStart();
                this.startLevel(); 
            }
            nextLevel() { 
                console.log('nextLevel called, current level:', this.level);
                // å¼ºåˆ¶é‡ç½® isProcessingï¼Œé˜²æ­¢å¡æ­»
                this.isProcessing = false;
                
                document.getElementById('winModal').classList.remove('show'); 
                CrazySDK.levelComplete(this.level);
                // Show ad between levels (every 3 levels)
                if (this.level % 3 === 0) {
                    console.log('Showing ad for level', this.level);
                    CrazySDK.requestAd(() => {
                        this.level++; 
                        console.log('Ad finished, starting level', this.level);
                        this.tools = { shuffle: 3, undo: 3, hint: 3 }; 
                        this.combo = 0; 
                        this.hasInteracted = false; 
                        this.hideTutorial();
                        // é‡æ–°è®¡ç®—çƒå¤§å°
                        this.handleResize();
                        this.startLevel();
                    });
                } else {
                    this.level++; 
                    console.log('Starting level', this.level);
                    this.tools = { shuffle: 3, undo: 3, hint: 3 }; 
                    this.combo = 0; 
                    this.hasInteracted = false; 
                    this.hideTutorial();
                    // é‡æ–°è®¡ç®—çƒå¤§å°
                    this.handleResize();
                    this.startLevel();
                }
            }
        }
        // CrazyGames SDK Integration
        const CrazySDK = {
            init: function() {
                if (typeof window.CrazyGames !== 'undefined') {
                    window.CrazyGames.SDK.init();
                    console.log('CrazyGames SDK initialized');
                }
            },
            
            // Call when game starts
            gameStart: function() {
                if (typeof window.CrazyGames !== 'undefined') {
                    window.CrazyGames.SDK.game.gameplayStart();
                }
            },
            
            // Call when game ends
            gameEnd: function() {
                if (typeof window.CrazyGames !== 'undefined') {
                    window.CrazyGames.SDK.game.gameplayStop();
                }
            },
            
            // Call when level completes
            levelComplete: function(level) {
                if (typeof window.CrazyGames !== 'undefined') {
                    window.CrazyGames.SDK.game.happyTime();
                }
            },
            
            // Request ad (call between levels)
            requestAd: function(callback) {
                if (typeof window.CrazyGames !== 'undefined') {
                    window.CrazyGames.SDK.ad.requestAd('midgame', {
                        adStarted: () => console.log('Ad started'),
                        adFinished: () => { console.log('Ad finished'); if (callback) callback(); },
                        adError: (error) => { console.log('Ad error:', error); if (callback) callback(); }
                    });
                } else if (callback) {
                    callback();
                }
            }
        };
        
        CrazySDK.init();
        const game = new Game();
    </script>
</body>
</html>